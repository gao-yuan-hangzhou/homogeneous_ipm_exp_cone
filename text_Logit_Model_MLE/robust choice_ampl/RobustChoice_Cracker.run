# Call solver and give it options
  

#option cplex_options 'iterations = 500', solver cplex; 
#option minos_options $minos_options 'meminc=7.65';
#option solver kestrel, kestrel_options 'solver=knitro';
#option mosek_options 'outlev=3 msk_dpar_intpnt_tol_pfeas=1.0e-8 wantsol = 1', solver mosek;
option snopt_options 'timing=1 maxfwd=10', solver snopt;
#option knitro options 'maxit=500 opttol=1.0e-5', solver knitro;

model RobustChoice_Cracker.mod; # comment for neos;
data RobustChoice_Cracker.dat;  # comment for neos;


for{s in 1..500 } {
  update data Xest;
  for{n in NP} {   
  let {t in 1..15}  Xest[n, t] := iniXest[ind[s, n], t];
  }

for {m in 1..20} {
       if m ==1 then {
          let gamma := 0.0001;
       }
   else {let gamma := m - 1;
  }
  solve RobustChoice; 
  
  ### return messages under knitro_neos#### 
#  display s, alpha[1],alpha[2],alpha[3],alpha[4], betaP, betaD, betaF, LogLikelihood, gamma, solve_result_num; # for neos;
  
  ### returen meassages under snopt_local####
# printf "%u\t %10.7f\t %10.7f\t %10.7f\t %10.7f %10.7f\t %10.7f\t %10.7f\t %10.7f\t %u\t %u\n",
#    s, alpha[1],alpha[2],alpha[3],alpha[4], betaP, betaD, betaF, LogLikelihood, gamma, solve_result_num >> RobustChoice_CrackerSol.txt; 
 if match (solve_message, "Optimal solution found") > 0 then {
  printf " %u\t %10.7f\t %10.7f\t %10.7f\t %10.7f %10.7f\t %10.7f\t %10.7f\t %10.7f\t %u\t %u\t Optimal solution found\n",
   s, alpha[1],alpha[2],alpha[3],alpha[4], betaP, betaD, betaF, LogLikelihood, gamma, solve_result_num >> RobustChoice_CrackerSol.txt;
  }
  else if match (solve_message, "Cannot satisfy nonlinear constraints") > 0 then { 
  printf " %u\t %10.7f\t %10.7f\t %10.7f\t %10.7f %10.7f\t %10.7f\t %10.7f\t %10.7f\t %u\t %u\t Cannot satisfy nonlinear constraints\n",
  s, alpha[1],alpha[2],alpha[3],alpha[4], betaP, betaD, betaF, LogLikelihood, gamma, solve_result_num >> RobustChoice_CrackerSol.txt;
  }
  else if match (solve_message, "Requested accuracy could not be achieved") > 0 then { 
  printf " %u\t %10.7f\t %10.7f\t %10.7f\t %10.7f %10.7f\t %10.7f\t %10.7f\t %10.7f\t %u\t %u\t Requested accuracy could not be achieved\n",
  s, alpha[1],alpha[2],alpha[3],alpha[4], betaP, betaD, betaF, LogLikelihood, gamma, solve_result_num >> RobustChoice_CrackerSol.txt;
  }
  else{
    printf " %u\t %10.7f\t %10.7f\t %10.7f\t %10.7f %10.7f\t %10.7f\t %10.7f\t %10.7f\t %u\t %u\t other\n",
   s, alpha[1],alpha[2],alpha[3],alpha[4], betaP, betaD, betaF, LogLikelihood, gamma, solve_result_num >> RobustChoice_CrackerSol.txt;
  }

 # display alpha;
 # display betaP, betaD, betaF;
 # display LogLikelihood;
 # display solve_exitcode;
  # printf "%10.7f \n", solve_exitcode > SNOPTExitEst.sol ; 
 # printf "%10.7f \n", _solve_time > solvetimeEst.sol;
  #printf "%10.7f \n", LogLikelihood > objvalEst.sol;     
  #printf "%10.7f\t %10.7f\t %10.7f\t %10.7f\n", alpha[1],alpha[2],alpha[3],alpha[4] > alphaEst.sol;
  #printf "%10.7f\t %10.7f\t %10.7f\n", betaP, betaD, betaF > betaEst.sol;
#for# {m in 30..30 } {
 # 	printf "%10.7f \n", p[m,1] > p1Est.sol;
  #	printf "%10.7f \n", p[m,2] > p2Est.sol;
  #}
# }
}
}